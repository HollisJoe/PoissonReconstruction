#include "vtkPoissonReconstruction.h"

#include "vtkObjectFactory.h"
#include "vtkStreamingDemandDrivenPipeline.h"
#include "vtkInformationVector.h"
#include "vtkInformation.h"
#include "vtkDataObject.h"
#include "vtkSmartPointer.h"

#include "MultiGridOctest.h"
#include "MultiGridOctreeData.h"
#include "CmdLineParser.h"
#include "ply.h"
#include "MemoryUsage.h"

vtkCxxRevisionMacro(vtkPoissonReconstruction, "$Revision: 1.70 $");
vtkStandardNewMacro(vtkPoissonReconstruction);

vtkPoissonReconstruction::vtkPoissonReconstruction()
{
}

int vtkPoissonReconstruction::RequestData(vtkInformation *vtkNotUsed(request),
                                             vtkInformationVector **inputVector,
                                             vtkInformationVector *outputVector)
{
  
  // get the info objects
  vtkInformation *inInfo = inputVector[0]->GetInformationObject(0);
  vtkInformation *outInfo = outputVector->GetInformationObject(0);
    
  // get the input and ouptut
  vtkPolyData *input = vtkPolyData::SafeDownCast(
      inInfo->Get(vtkDataObject::DATA_OBJECT()));
  
  vtkPolyData *output = vtkPolyData::SafeDownCast(
      outInfo->Get(vtkDataObject::DATA_OBJECT()));
    
  const int Degree = 2;
  int i;
  cmdLineString In,Out;
  cmdLineReadable Binary,Verbose,NoResetSamples,NoClipTree,Confidence;
  cmdLineInt Depth(8),SolverDivide(8),IsoDivide(8),Refine(3);
  cmdLineInt KernelDepth;
  cmdLineFloat SamplesPerNode(1.0f),Scale(1.25f);
  char* paramNames[]=
  {
      (char *)"in",(char *)"depth",(char *)"out",(char *)"refine",(char *)"noResetSamples",(char *)"noClipTree",
      (char *)"binary",(char *)"solverDivide",(char *)"isoDivide",(char *)"scale",(char *)"verbose",
      (char *)"kernelDepth",(char *)"samplesPerNode",(char *)"confidence"
  };
  cmdLineReadable* params[]=
  {
      &In,&Depth,&Out,&Refine,&NoResetSamples,&NoClipTree,
      &Binary,&SolverDivide,&IsoDivide,&Scale,&Verbose,
      &KernelDepth,&SamplesPerNode,&Confidence
  };
  int paramNum=sizeof(paramNames)/sizeof(char*);
  int commentNum=0;
  char **comments;

  comments=new char*[paramNum+7];
  for(i=0;i<paramNum+7;i++)
    {
    comments[i]=new char[1024];
    }

  const char* Rev = "Rev: V2 ";
  const char* Date = "Date: 2006-11-09 (Thur, 09 Nov 2006) ";

  cmdLineParse(argc-1,&argv[1],paramNames,paramNum,params,0);

  DumpOutput2(comments[commentNum++],"Running Multi-Grid Octree Surface Reconstructor (degree %d). Version 2\n", Degree);
  
  if(In.set)				{DumpOutput2(comments[commentNum++],"\t--in %s\n",In.value);}
  if(Out.set)				{DumpOutput2(comments[commentNum++],"\t--out %s\n",Out.value);}
  if(Binary.set)			{DumpOutput2(comments[commentNum++],"\t--binary\n");}
  if(Depth.set)			{DumpOutput2(comments[commentNum++],"\t--depth %d\n",Depth.value);}
  if(SolverDivide.set)	{DumpOutput2(comments[commentNum++],"\t--solverDivide %d\n",SolverDivide.value);}
  if(IsoDivide.set)		{DumpOutput2(comments[commentNum++],"\t--isoDivide %d\n",IsoDivide.value);}
  if(Refine.set)			{DumpOutput2(comments[commentNum++],"\t--refine %d\n",Refine.value);}
  if(Scale.set)			{DumpOutput2(comments[commentNum++],"\t--scale %f\n",Scale.value);}
  if(KernelDepth.set)		{DumpOutput2(comments[commentNum++],"\t--kernelDepth %d\n",KernelDepth.value);}
  if(SamplesPerNode.set)	{DumpOutput2(comments[commentNum++],"\t--samplesPerNode %f\n",SamplesPerNode.value);}
  if(NoResetSamples.set)	{DumpOutput2(comments[commentNum++],"\t--noResetSamples\n");}
  if(NoClipTree.set)		{DumpOutput2(comments[commentNum++],"\t--noClipTree\n");}
  if(Confidence.set)		{DumpOutput2(comments[commentNum++],"\t--confidence\n");}

  double t;
  double tt=Time();
  Point3D<float> center;
  Real scale=1.0;
  Real isoValue=0;
  Octree<Degree> tree;
  PPolynomial<Degree> ReconstructionFunction = PPolynomial<Degree>::GaussianApproximation();

  center.coords[0]=center.coords[1]=center.coords[2]=0;
  if(!In.set || !Out.set)
    {
    ShowUsage(argv[0]);
    return 0;
    }
  
  TreeOctNode::SetAllocator(MEMORY_ALLOCATOR_BLOCK_SIZE);

  t=Time();
  int kernelDepth=Depth.value-2;
  if(KernelDepth.set)
    {
    kernelDepth=KernelDepth.value;
    }

  tree.setFunctionData(ReconstructionFunction,Depth.value,0,Real(1.0)/(1<<Depth.value));
  DumpOutput("Function Data Set In: %lg\n",Time()-t);
  DumpOutput("Memory Usage: %.3f MB\n",float(MemoryInfo::Usage())/(1<<20));
  if(kernelDepth>Depth.value)
    {
    fprintf(stderr,"KernelDepth can't be greater than Depth: %d <= %d\n",kernelDepth,Depth.value);
    return EXIT_FAILURE;
    }


  t=Time();

  tree.setTree(In.value,Depth.value,Binary.set,kernelDepth,Real(SamplesPerNode.value),Scale.value,center,scale,!NoResetSamples.set,Confidence.set);

  DumpOutput2(comments[commentNum++],"#             Tree set in: %9.1f (s), %9.1f (MB)\n",Time()-t,tree.maxMemoryUsage);
  DumpOutput("Leaves/Nodes: %d/%d\n",tree.tree.leaves(),tree.tree.nodes());
  DumpOutput("   Tree Size: %.3f MB\n",float(sizeof(TreeOctNode)*tree.tree.nodes())/(1<<20));
  DumpOutput("Memory Usage: %.3f MB\n",float(MemoryInfo::Usage())/(1<<20));

  if(!NoClipTree.set)
    {
    t=Time();
    tree.ClipTree();
    DumpOutput("Tree Clipped In: %lg\n",Time()-t);
    DumpOutput("Leaves/Nodes: %d/%d\n",tree.tree.leaves(),tree.tree.nodes());
    DumpOutput("   Tree Size: %.3f MB\n",float(sizeof(TreeOctNode)*tree.tree.nodes())/(1<<20));
    }

  t=Time();
  tree.finalize1(Refine.value);
  DumpOutput("Finalized 1 In: %lg\n",Time()-t);
  DumpOutput("Leaves/Nodes: %d/%d\n",tree.tree.leaves(),tree.tree.nodes());
  DumpOutput("Memory Usage: %.3f MB\n",float(MemoryInfo::Usage())/(1<<20));

  t=Time();
  tree.maxMemoryUsage=0;
  tree.SetLaplacianWeights();
  DumpOutput2(comments[commentNum++],"#Laplacian Weights Set In: %9.1f (s), %9.1f (MB)\n",Time()-t,tree.maxMemoryUsage);
  DumpOutput("Memory Usage: %.3f MB\n",float(MemoryInfo::Usage())/(1<<20));

  t=Time();
  tree.finalize2(Refine.value);
  DumpOutput("Finalized 2 In: %lg\n",Time()-t);
  DumpOutput("Leaves/Nodes: %d/%d\n",tree.tree.leaves(),tree.tree.nodes());
  DumpOutput("Memory Usage: %.3f MB\n",float(MemoryInfo::Usage())/(1<<20));

  tree.maxMemoryUsage=0;
  t=Time();
  tree.LaplacianMatrixIteration(SolverDivide.value);
  DumpOutput2(comments[commentNum++],"# Linear System Solved In: %9.1f (s), %9.1f (MB)\n",Time()-t,tree.maxMemoryUsage);
  DumpOutput("Memory Usage: %.3f MB\n",float(MemoryInfo::Usage())/(1<<20));

  CoredVectorMeshData mesh;
  tree.maxMemoryUsage=0;
  t=Time();
  isoValue=tree.GetIsoValue();
  DumpOutput("Got average in: %f\n",Time()-t);
  DumpOutput("Iso-Value: %e\n",isoValue);
  DumpOutput("Memory Usage: %.3f MB\n",float(tree.MemoryUsage()));

  t=Time();
  if(IsoDivide.value)
    {
    tree.GetMCIsoTriangles(isoValue,IsoDivide.value,&mesh);
    }
  else
    {
    tree.GetMCIsoTriangles(isoValue,&mesh);
    }
  DumpOutput2(comments[commentNum++],"#        Got Triangles in: %9.1f (s), %9.1f (MB)\n",Time()-t,tree.maxMemoryUsage);
  DumpOutput2(comments[commentNum++],"#              Total Time: %9.1f (s)\n",Time()-tt);
  PlyWriteTriangles(Out.value,&mesh,PLY_BINARY_NATIVE,center,scale,comments,commentNum);

  
  output->ShallowCopy(input);
    
  return 1;
}


//----------------------------------------------------------------------------
void vtkPoissonReconstruction::PrintSelf(ostream& os, vtkIndent indent)
{
  this->Superclass::PrintSelf(os,indent);
}

